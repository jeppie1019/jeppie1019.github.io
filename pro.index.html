<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>éš¨æ©Ÿæ•¸ç¨éŠæˆ²</title>
    <style>
        /* --- CSS æ¨£å¼ --- */
        body {
            font-family: Arial, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #f4f4f4;
            margin: 0;
        }

        .container {
            text-align: center;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.2);
        }

        h1 {
            color: #333;
        }

        .grid {
            display: grid;
            grid-template-columns: repeat(9, 1fr);
            grid-template-rows: repeat(9, 1fr);
            width: 450px; 
            height: 450px; 
            border: 3px solid #333;
            margin: 20px auto;
        }

        .cell {
            width: 50px;
            height: 50px;
            border: 1px solid #ccc;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 20px;
            font-weight: bold;
            box-sizing: border-box; 
            cursor: pointer;
            background-color: #fff;
            user-select: none; 
            outline: none;
        }

        .cell.fixed {
            background-color: #eee;
            color: #333;
            cursor: default;
        }

        .cell.editable {
            color: #007bff; 
        }
        
        .cell:focus {
            background-color: #ffffcc; 
        }
        
        .cell.error {
            background-color: #ffdddd; 
            color: #cc0000 !important; 
        }

        /* ç²—ç·šåˆ†éš” 3x3 å®®æ ¼ */
        .cell:nth-child(3n) { border-right: 3px solid #333; }
        .cell:nth-child(9n + 1) { border-left: none; }
        .cell:nth-child(9n):not(:nth-child(81)) { border-right: none; }
        .cell:nth-child(27n) ~ .cell { border-top: 3px solid #333; }
        
        .cell:nth-child(1), .cell:nth-child(2), .cell:nth-child(3),
        .cell:nth-child(10), .cell:nth-child(11), .cell:nth-child(12),
        .cell:nth-child(19), .cell:nth-child(20), .cell:nth-child(21) { border-top: none; }
        .cell:nth-child(27n) { border-bottom: 3px solid #333; }
        .grid .cell:nth-last-child(-n+9) { border-bottom: none !important; }

        .controls button {
            padding: 10px 20px;
            margin: 10px 10px;
            font-size: 16px;
            cursor: pointer;
            border: 1px solid #007bff;
            background-color: #007bff;
            color: white;
            border-radius: 4px;
            transition: background-color 0.3s;
        }

        .controls button:hover {
            background-color: #0056b3;
        }
        
        #message {
            font-weight: bold;
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>æ•¸ç¨éŠæˆ²</h1>
        
        <div id="sudoku-grid" class="grid">
            </div>

        <div class="controls">
            <button id="solve-button">è‡ªå‹•æ±‚è§£</button>
            <button id="new-game-button">æ–°éŠæˆ²</button>
        </div>
        
        <p id="message"></p>
    </div>

    <script>
        /* --- JavaScript æ ¸å¿ƒé‚è¼¯ --- */
        const GRID_SIZE = 9;
        const gridElement = document.getElementById('sudoku-grid');
        const solveButton = document.getElementById('solve-button');
        const newGameButton = document.getElementById('new-game-button');
        const messageElement = document.getElementById('message');

        let currentGrid = []; 
        let initialGrid = []; 

        // --- æ ¸å¿ƒæ¼”ç®—æ³•ï¼šå›æº¯æ³•æª¢æŸ¥èˆ‡æ±‚è§£ ---

        /**
         * æª¢æŸ¥åœ¨çµ¦å®šä½ç½® (row, col) æ”¾ç½® number æ˜¯å¦æœ‰æ•ˆã€‚
         */
        function isValid(board, row, col, number) {
            // æª¢æŸ¥è¡Œå’Œåˆ—
            for (let k = 0; k < GRID_SIZE; k++) {
                if (board[row][k] === number || board[k][col] === number) {
                    return false;
                }
            }

            // æª¢æŸ¥ 3x3 å®®æ ¼
            const boxRowStart = row - (row % 3);
            const boxColStart = col - (col % 3);
            for (let i = 0; i < 3; i++) {
                for (let j = 0; j < 3; j++) {
                    if (board[boxRowStart + i][boxColStart + j] === number) {
                        return false;
                    }
                }
            }
            return true;
        }
        
        /**
         * æª¢æŸ¥ç•¶å‰ç”¨æˆ¶è¼¸å…¥çš„æ•¸å­—æ˜¯å¦èˆ‡æ•¸ç¨è¦å‰‡è¡çª
         */
        function isUserMoveValid(board, row, col, number) {
            // æš«æ™‚å°‡ç•¶å‰ä½ç½®è¨­ç‚º 0ï¼Œé¿å…æª¢æŸ¥åˆ°è‡ªèº«
            let temp = board[row][col];
            board[row][col] = 0; 
            const valid = isValid(board, row, col, number);
            board[row][col] = temp; // æ¢å¾©æ•¸å­—
            return valid;
        }

        /**
         * Fisher-Yates æ´—ç‰Œæ¼”ç®—æ³• (ç”¨æ–¼æ‰“äº‚é™£åˆ—)
         */
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        /**
         * å¯¦ç¾éš¨æ©Ÿé †åºçš„å›æº¯æ³•æ±‚è§£ï¼ˆç”¨æ–¼ç”Ÿæˆä¸åŒçš„è§£ï¼‰
         * 
         */
        function solveSudoku(board) {
            for (let i = 0; i < GRID_SIZE; i++) {
                for (let j = 0; j < GRID_SIZE; j++) {
                    if (board[i][j] === 0) {
                        
                        // ä½¿ç”¨éš¨æ©Ÿé †åºå˜—è©¦ 1-9
                        const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9];
                        shuffleArray(numbers); 

                        for (const number of numbers) {
                            if (isValid(board, i, j, number)) {
                                board[i][j] = number;
                                if (solveSudoku(board)) {
                                    return true;
                                }
                                board[i][j] = 0; // å›æº¯ (Backtrack)
                            }
                        }
                        return false;
                    }
                }
            }
            return true;
        }
        
        // --- éŠæˆ²ç”Ÿæˆèˆ‡æ¸²æŸ“ ---

        /**
         * å‰µå»ºä¸€å€‹ç©ºçš„ 9x9 æ•¸ç¨æ¿ (ç”¨ 0 å¡«å……)
         */
        function createEmptyBoard() {
            return Array(GRID_SIZE).fill(0).map(() => Array(GRID_SIZE).fill(0));
        }

        /**
         * éš¨æ©Ÿç”Ÿæˆä¸€å€‹æœ‰æ•ˆçš„æ•¸ç¨è¬é¡Œ
         */
        function generateSudoku() {
            let board = createEmptyBoard();
            
            // 1. ç”Ÿæˆä¸€å€‹éš¨æ©Ÿçš„å®Œæ•´æ•¸ç¨è§£
            if (!solveSudoku(board)) {
                console.error("ç„¡æ³•ç”Ÿæˆæ•¸ç¨å®Œæ•´è§£ï¼");
                return createEmptyBoard();
            }
            
            let puzzle = board; 
            
            // 2. éš¨æ©ŸæŒ–æ´ (é›£åº¦è¨­ç½®)
            // æ•¸å€¼è¶Šå¤§ï¼Œç©ºä½è¶Šå¤šï¼Œé›£åº¦è¶Šé«˜
            let holes = 45; 
            let count = 0;
            while (count < holes) {
                let r = Math.floor(Math.random() * 9);
                let c = Math.floor(Math.random() * 9);
                if (puzzle[r][c] !== 0) {
                    puzzle[r][c] = 0;
                    count++;
                }
            }
            
            return puzzle;
        }


        /**
         * æ¸²æŸ“æ•¸ç¨éŠæˆ²æ¿åˆ° HTML 
         */
        function renderGrid(board, highlightErrors = false) {
            gridElement.innerHTML = ''; 

            for (let i = 0; i < GRID_SIZE; i++) {
                for (let j = 0; j < GRID_SIZE; j++) {
                    const cell = document.createElement('div');
                    cell.classList.add('cell');
                    cell.dataset.row = i;
                    cell.dataset.col = j;
                    
                    const value = board[i][j];
                    
                    if (initialGrid[i][j] !== 0) {
                        cell.textContent = value;
                        cell.classList.add('fixed');
                    } else {
                        if (value !== 0) {
                            cell.textContent = value;
                            cell.classList.add('editable');
                            
                            // å¦‚æœéœ€è¦é«˜äº®é¡¯ç¤ºéŒ¯èª¤ï¼Œå‰‡æª¢æŸ¥
                            if (highlightErrors && !isUserMoveValid(board, i, j, value)) {
                                cell.classList.add('error');
                                cell.setAttribute('title', 'é€™å€‹æ•¸å­—èˆ‡è¡Œã€åˆ—æˆ–å®®æ ¼å…§çš„æ•¸å­—è¡çª');
                            }
                        }
                        
                        cell.contentEditable = 'true'; 
                        cell.setAttribute('inputmode', 'numeric');
                        cell.addEventListener('input', handleCellInput);
                        cell.addEventListener('keydown', restrictInput);
                    }
                    gridElement.appendChild(cell);
                }
            }
        }

        // --- ç”¨æˆ¶è¼¸å…¥è™•ç† ---

        function restrictInput(event) {
            const key = event.key;
            // å…è¨±æ§åˆ¶éµ
            if (['Backspace', 'Delete', 'ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown', 'Tab'].includes(key)) {
                return; 
            }
            // åªå…è¨± 1-9 çš„æ•¸å­—éµ
            if (!/^[1-9]$/.test(key)) {
                event.preventDefault();
            }
            // ç¢ºä¿å–®å…ƒæ ¼å…§åªä¿ç•™ä¸€å€‹å­—ç¬¦
            if (event.target.textContent.length >= 1 && !['Backspace', 'Delete'].includes(key)) {
                event.preventDefault();
            }
        }


        function handleCellInput(event) {
            const cell = event.target;
            let value = cell.textContent.trim();
            const row = parseInt(cell.dataset.row);
            const col = parseInt(cell.dataset.col);

            // æ¸…ç†å’Œé©—è­‰è¼¸å…¥
            if (!/^[1-9]$/.test(value)) {
                cell.textContent = ''; 
                currentGrid[row][col] = 0;
            } else {
                cell.textContent = value; 
                currentGrid[row][col] = parseInt(value);
            }
            
            // é‡æ–°æ¸²æŸ“ä»¥æª¢æŸ¥éŒ¯èª¤ (é€™æ˜¯æœ€ç°¡å–®çš„éŒ¯èª¤é«˜äº®æ–¹å¼)
            renderGrid(currentGrid, true); 
            
            // æª¢æŸ¥éŠæˆ²æ˜¯å¦å®Œæˆ
            if (checkIfSolved()) {
                updateMessage('ğŸ‰ æ­å–œï¼æ•¸ç¨å·²è§£é–‹ï¼', 'green');
            } else {
                // å¦‚æœç•¶å‰å–®å…ƒæ ¼æ²’æœ‰éŒ¯èª¤ï¼Œä¸”æ²’æœ‰å…¶ä»–å®Œæˆè¨Šæ¯ï¼Œå‰‡æ¸…ç©º
                if (!cell.classList.contains('error')) {
                     updateMessage('');
                }
            }
        }

        function checkIfSolved() {
            // æª¢æŸ¥æ˜¯å¦æœ‰ç©ºä½
            for(let i=0; i<GRID_SIZE; i++) {
                for(let j=0; j<GRID_SIZE; j++) {
                    if (currentGrid[i][j] === 0) {
                        return false; 
                    }
                }
            }
            
            // æª¢æŸ¥æ˜¯å¦æœ‰è¡çª
            for(let i=0; i<GRID_SIZE; i++) {
                for(let j=0; j<GRID_SIZE; j++) {
                    let number = currentGrid[i][j];
                    if (!isUserMoveValid(currentGrid, i, j, number)) {
                        return false; 
                    }
                }
            }
            return true;
        }

        function updateMessage(text, color = 'red') {
            messageElement.textContent = text;
            messageElement.style.color = color;
        }

        /**
         * åˆå§‹åŒ–éŠæˆ²
         */
        function initGame() {
            messageElement.textContent = '';
            
            // 1. ç”Ÿæˆæ–°çš„éš¨æ©Ÿæ•¸ç¨è¬é¡Œ
            initialGrid = generateSudoku();
            currentGrid = initialGrid.map(row => [...row]); 
            
            // 2. æ¸²æŸ“éŠæˆ²æ¿
            renderGrid(currentGrid);
        }

        // --- äº‹ä»¶ç›£è½å™¨ ---
        solveButton.addEventListener('click', () => {
            let boardToSolve = initialGrid.map(row => [...row]); 
            
            if (solveSudoku(boardToSolve)) {
                currentGrid = boardToSolve; 
                renderGrid(currentGrid, false); 
                updateMessage('âœ… æ•¸ç¨å·²è‡ªå‹•æ±‚è§£å®Œç•¢ï¼', 'blue');
            } else {
                updateMessage('âŒ éŒ¯èª¤ï¼šè©²æ•¸ç¨ç„¡è§£ã€‚');
            }
        });

        newGameButton.addEventListener('click', initGame);


        // --- å•Ÿå‹•éŠæˆ² ---
        document.addEventListener('DOMContentLoaded', initGame);
    </script>
</body>
</html>
